csrf 개념 정리
공격자가 사용자가 이미 인증된 세션을 가지고 있음을 이용함. 사용자가 방문하는 다른 웹페이지에 악의적인 링크를 배치하고 사용자는 이걸 아무생각없이 누름 → 사용자는 facebook에 자기계정으로 인증되어있으니 수행 가능함 각 form 요청에 대해 유니크한 csrf 토큰 생성하고 서버에서 검증함. 사용자의 요청은 토큰 검증이 끝나야 수행할 수 있음
thymeleaf 에서는 아래와 같이 사용 <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" /> csrf토큰의 파라미터 이름을 동적으로 설정함. 기본적으로 시큐리티는 _csrf이름 사용 csrf 보호 기능이 설정되어있다면 서버는 폼 제출 시 csrf 토큰을 검증함. 토큰 없거나 일치하지 않으면 시큐리티는 요청 거부.
samesite 쿠키는 csrf방어에 도움이 됨 브라우저가 쿠키를 다른 사이트의 요청과 함께 보내는 방식을 제한함. strict쿠키는 동일한 도메인 요청에서만 전송됨. none쿠키는 모든 요청에 대해 전송됨 lax쿠키는 get에서는 쿠키 전송하는데 post나 다른거는 쿠키 전송 안함
스프링 시큐리티에서는 사용자가 웹 애플리케이션에 접속할 때 csrf토큰을 생성함. 이건 사용자의 세션에 저장되고 세션마다 고유함. 생성된 토큰은 html의 hidden 필드나 쿠키를 통해 브라우저에 전달. 서버에서는 요청 받을 때 마다 csrf토큰이 세션에 저장된 토큰과 일치하는지 비교 로그인 할 때 마다 새로운 토큰 생성함
jwt는 서버에서 세션을 사용하지 않음. 사용자의 브라우저에 localstorage나 sessionstorage나 cookie에 jwt 저장
xss공격 정리
해커는 사용자가 접속한 url에 스크립트를 심어두고 실행하도록 함 csrf는 사용자의 로그인 정보가 있을 법 한 사이트의 url을 심어두는 것 url을 누르면 스크립트가 실행되고 이 스크립트는 세션 쿠키 탈취하거나 민감한 정보를 수집함
세션 - 쿠키 기반 인증과 jwt 기반 인증 정리
세션 - 쿠키 인증은 쿠키에 사용자의 세션 id만 저장하고 세션id는 서버에서 생성하고 이 id를 통해 서버는 세션 저장소에서 사용자의 인증 상태와 관련 데이터를 조회함.
jwt기반 인증은 쿠키에 인증 정보가 포함된 토큰이 저장됨. 서버는 디지털 서명을 통해 보호되는 토큰이 변조되지 않음만 확인함 서버의 비밀키로 서명되어있으니 비밀키를 사용해 서명이 유효한지만 확인하면 됨 그러니 서버는 인증 상태를 별도로 저장하고 관리할 필요가 없어짐 아 물론 jwt를 쿠키 말고 로컬스토리지나 세션스토리지에 저장하는 경우도 있긴 함 중요한건 이 jwt가 인증 정보가 직접 포함된 완결된 토큰이라는거임
jwt는 csrf 공격에 대한 방어가 쉬움
jwt가 http요청의 헤더에 포함되어 서버에 전송됨 요점은 세션-쿠키 기반 인증에서는 브라우저가 자동으로 모든 http 요청과 함께 쿠키를 전송하는거임. jwt기반 인증에서는 명시적으로 Authorization 헤더에 쿠키를 포함시켜야 함 브라우저는 자동으로 jwt를 요청에 포함시키지 않음.
브라우저가 자동으로 쿠키를 HTTP 포함시키는 과정은 브라우저의 내장 기능에 의해 수행됨 쿠키-세션 기반 인증에서는 set-cookie 헤더에다가 브라우저에 세션 쿠키를 설정하는데 브라우저는 이 쿠키를 받아서 사용자의 장치에 저장함. 그리고 사용자가 동일한 도메인에 요청 보낼 때 저장된 쿠키를 요청의 cookie 헤더에 자동으로 포함시키게 됨. 이건 내부적으로 처리된다..
그러니!!!!!!!!! jwt를 쓰면 자동으로 jwt를 요청에 포함하지 않게 되니 기본적으로 csrf에서 보호받게 되는 것..
그런데 ibs는 jwt기반인증이 아니고 restapi도 아님 그러니 csrf토큰 필요함
